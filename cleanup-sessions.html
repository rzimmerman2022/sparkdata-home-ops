<!DOCTYPE html>
<html>
<head>
    <title>Session Cleanup Tool</title>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; max-width: 800px; margin: 0 auto; }
        .session { background: #f5f5f5; padding: 15px; margin: 10px 0; border-radius: 8px; }
        .active { background: #d1fae5; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        .danger { background: #ef4444; color: white; border: none; border-radius: 6px; }
        .success { background: #10b981; color: white; border: none; border-radius: 6px; }
        h2 { color: #333; margin-top: 30px; }
    </style>
</head>
<body>
    <h1>ðŸ§¹ Session Cleanup Tool</h1>
    <p>This tool helps you close old/duplicate active sessions that weren't properly ended.</p>

    <div>
        <button class="danger" onclick="closeOldSessions()">Close Sessions Older Than 30 Minutes</button>
        <button class="danger" onclick="closeDuplicateSessions()">Close Duplicate Sessions (Keep Most Recent Per Person)</button>
        <button class="success" onclick="location.reload()">Refresh</button>
    </div>

    <div id="output"></div>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyCVHDGBL70opBifmdnILzrUYEptQsMw708",
            authDomain: "sparkdata-cleaning-checklists.firebaseapp.com",
            projectId: "sparkdata-cleaning-checklists",
            storageBucket: "sparkdata-cleaning-checklists.firebasestorage.app",
            messagingSenderId: "825900465348",
            appId: "1:825900465348:web:d28f2742e527513311dd91"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        async function loadSessions() {
            const output = document.getElementById('output');
            const snapshot = await db.collection('sessions/dec10-2025/cleaners')
                .where('status', '==', 'active')
                .get();

            let html = '<h2>Active Sessions</h2>';
            html += `<p>Found ${snapshot.size} active sessions</p>`;

            snapshot.forEach(doc => {
                const data = doc.data();
                const startTime = data.startTime ? data.startTime.toDate() : null;
                const now = new Date();
                const minutesAgo = startTime ? Math.round((now - startTime) / 60000) : 0;

                html += `
                    <div class="session active">
                        <strong>${data.name || 'Unknown'}</strong><br>
                        Started: ${startTime ? startTime.toLocaleString() : 'Unknown'} (${minutesAgo} min ago)<br>
                        Tasks: ${data.tasksCompleted || 0}<br>
                        ID: ${doc.id}
                    </div>
                `;
            });

            output.innerHTML = html;
        }

        async function closeOldSessions() {
            if (!confirm('Close all sessions older than 30 minutes?')) return;

            const snapshot = await db.collection('sessions/dec10-2025/cleaners')
                .where('status', '==', 'active')
                .get();

            const now = new Date();
            const batch = db.batch();
            let count = 0;

            snapshot.forEach(doc => {
                const data = doc.data();
                const startTime = data.startTime ? data.startTime.toDate() : null;
                const minutesAgo = startTime ? (now - startTime) / 60000 : 999;

                if (minutesAgo > 30) {
                    batch.update(doc.ref, {
                        status: 'completed',
                        endTime: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    count++;
                }
            });

            await batch.commit();
            alert(`Closed ${count} old sessions`);
            loadSessions();
        }

        async function closeDuplicateSessions() {
            if (!confirm('Close duplicate sessions (keep most recent per person)?')) return;

            const snapshot = await db.collection('sessions/dec10-2025/cleaners')
                .where('status', '==', 'active')
                .get();

            // Group by name
            const sessionsByName = {};
            snapshot.forEach(doc => {
                const data = doc.data();
                const name = data.name || 'Unknown';
                if (!sessionsByName[name]) {
                    sessionsByName[name] = [];
                }
                sessionsByName[name].push({ id: doc.id, ref: doc.ref, data });
            });

            const batch = db.batch();
            let count = 0;

            // For each person, keep only the most recent session
            Object.values(sessionsByName).forEach(sessions => {
                if (sessions.length > 1) {
                    // Sort by start time, most recent first
                    sessions.sort((a, b) => {
                        const timeA = a.data.startTime ? a.data.startTime.toDate() : new Date(0);
                        const timeB = b.data.startTime ? b.data.startTime.toDate() : new Date(0);
                        return timeB - timeA;
                    });

                    // Close all except the first (most recent)
                    for (let i = 1; i < sessions.length; i++) {
                        batch.update(sessions[i].ref, {
                            status: 'completed',
                            endTime: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        count++;
                    }
                }
            });

            await batch.commit();
            alert(`Closed ${count} duplicate sessions`);
            loadSessions();
        }

        // Load on page load
        loadSessions();
    </script>
</body>
</html>
